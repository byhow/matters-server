input AppreciateArticleInput {
  id: ID!
  amount: Int!
}

input ArchiveArticleInput {
  id: ID!
}

type Article implements Node {
  id: ID!
  slug: String!
  createdAt: DateTime!
  state: ArticleState!
  public: Boolean!
  live: Boolean!
  author: User!
  title: String!
  cover: URL
  summary: String!
  tags: [Tag!]
  wordCount: Int
  dataHash: String
  mediaHash: String
  content: String!
  gatewayUrls: [URL!]
  upstream: Article
  downstreams(input: ListInput!): [Article!]
  relatedArticles(input: ListInput!): [Article!]

  """MAT recieved for this article"""
  MAT: Int!
  participantCount: Int!
  participants: [User!]
  subscribers(input: ListInput!): [User!]
  appreciators(input: ListInput!): [User!]
  appreciatorCount: Int!

  """limit the nuhmber of appreciate per user"""
  appreciateLimit: Int!
  appreciateLeft: Int!

  """Viewer has appreciate"""
  hasAppreciate: Boolean!

  """Viewer has subscribed"""
  subscribed: Boolean!
  commentCount: Int!
  pinCommentLimit: Int!
  pinCommentLeft: Int!
  pinnedComments: [Comment!]
  comments(input: CommentsInput!): [Comment!]
}

input ArticleInput {
  mediaHash: String!
}

type ArticleNewAppreciationNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Article!
  MAT: Int!
}

type ArticleNewCommentNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Article!
  comment: Comment!
}

type ArticleNewDownstreamNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  downstream: Article!
  target: Article!
}

type ArticleNewSubscriberNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Article!
}

type ArticlePublishedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Article!
}

input ArticlesInput {
  public: Boolean
  offset: Int
  limit: Int
}

enum ArticleState {
  active
  archived
  banned
}

type Asset {
  id: ID!
  type: AssetType!
  path: String!
  createdAt: DateTime!
}

enum AssetType {
  avatar
  cover
  audioDraft
  report
  feedback
}

type AudioDraft {
  id: ID!
  authorId: ID!
  title: String
  audio: URL!
  length: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AuthResult {
  auth: Boolean!
  token: String
}

type Badge {
  type: BadgeType!
}

enum BadgeType {
  seed
}

type Category {
  id: ID!
  name: String!
}

enum ChannelType {
  appStore
  googlePlay
}

input ClearReadHistoryInput {
  id: ID!
}

type Comment implements Node {
  id: ID!
  state: CommentState!
  createdAt: DateTime!

  """Original article of this comment"""
  article: Article!
  content: String
  author: User!
  pinned: Boolean!
  upvotes: Int!
  downvotes: Int!
  quote: Boolean!
  myVote: Vote
  mentions: [User!]
  comments: [Comment!]
  parentComment: Comment
}

input CommentInput {
  content: String!
  quotation: String
  articleId: ID!
  parentId: ID
  mentions: [ID!]
}

type CommentMentionedYouNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actor: User!
  target: Comment!
}

type CommentNewReplyNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Comment!
  reply: Comment!
}

type CommentNewUpvoteNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Comment!
}

type CommentPinnedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actor: User!
  target: Comment!
}

input CommentsInput {
  offset: Int
  limit: Int
  author: ID
  quote: Boolean
  sort: CommentSort
  parent: Boolean
}

enum CommentSort {
  oldest
  newest
  upvotes
}

enum CommentState {
  active
  archived
  banned
}

input ConfirmChangeEmailInput {
  oldEmail: Email!
  oldEmailCodeId: ID!
  newEmail: Email!
  newEmailCodeId: ID!
}

input ConfirmResetPasswordInput {
  password: String!
  codeId: ID!
}

input ConfirmVerificationCodeInput {
  code: String!
}

input ConfirmVerifyEmailInput {
  email: Email!
  codeId: ID!
}

scalar Date

scalar DateTime

input DeleteAudioDraftInput {
  id: ID!
}

input DeleteCommentInput {
  id: ID!
}

input DeleteDraftInput {
  id: ID!
}

type DownstreamArticleArchivedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  downstream: Article!
  target: Article!
}

type Draft implements Node {
  id: ID!
  upstream: Article
  title: String
  summary: String
  content: String!
  scheduledAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [String!]
  cover: URL
  publishState: PublishState!
}

scalar Email

input FeedbackInput {
  category: ID!
  description: String
  assetIds: [ID!]
  contact: String
}

input FollowUserInput {
  id: ID!
}

input ImportArticlesInput {
  platform: String
  token: String
}

type Invitation implements Node {
  id: ID!
  user: User
  email: String
  accepted: Boolean!
  createdAt: DateTime!
}

type InvitationStatus {
  MAT: Int!

  """invitation number left"""
  left: Int!

  """invitations sent"""
  sent(input: ListInput!): [Invitation!]
}

input InviteInput {
  id: ID
  email: Email
}

scalar JSON

input ListInput {
  offset: Int
  limit: Int
}

type MAT {
  total: Int!
  history(input: ListInput!): [Transaction!]
}

type Mutation {
  _: Boolean
  publishArticle(input: PublishArticleInput!): Draft!
  archiveArticle(input: ArchiveArticleInput!): Article!
  subscribeArticle(input: SubscribeArticleInput!): Boolean
  unsubscribeArticle(input: UnsubscribeArticleInput!): Boolean
  reportArticle(input: ReportArticleInput!): Boolean
  appreciateArticle(input: AppreciateArticleInput!): Article!
  readArticle(input: ReadArticleInput!): Boolean
  recallPublish(input: RecallPublishInput!): Draft!
  toggleArticleLive(input: ToggleArticleLiveInput!): Article!
  toggleArticlePublic(input: ToggleArticlePublicInput!): Article!
  putComment(input: PutCommentInput!): Comment!
  pinComment(input: PinCommentInput!): Comment!
  deleteComment(input: DeleteCommentInput!): Boolean
  reportComment(input: ReportCommentInput!): Boolean
  voteComment(input: VoteCommentInput!): Comment!
  unvoteComment(input: UnvoteCommentInput!): Comment!

  """audio dtaft"""
  putAudioDraft(input: PutAudioDraftInput!): AudioDraft!
  deleteAudioDraft(input: DeleteAudioDraftInput!): Boolean

  """draft"""
  putDraft(input: PutDraftInput!): Draft!
  deleteDraft(input: DeleteDraftInput!): Boolean
  markAllNoticesAsRead: Boolean
  singleFileUpload(input: SingleFileUploadInput!): Asset!
  feedback(input: FeedbackInput!): Boolean

  """send/confirm verification code"""
  sendVerificationCode(input: SendVerificationCodeInput!): Boolean
  confirmVerificationCode(input: ConfirmVerificationCodeInput!): ID!

  """change or reset password"""
  confirmResetPassword(input: ConfirmResetPasswordInput!): Boolean

  """change email"""
  confirmChangeEmail(input: ConfirmChangeEmailInput!): Boolean

  """verify email"""
  confirmVerifyEmail(input: ConfirmVerifyEmailInput!): Boolean

  """register"""
  userRegister(input: UserRegisterInput!): AuthResult!

  """login"""
  userLogin(input: UserLoginInput!): AuthResult!

  """
  addOAuth(input: AddOAuthInput!): Boolean
  update info/ setting
  """
  updateUserInfo(input: UpdateUserInfoInput!): User!
  updateNotificationSetting(input: UpdateNotificationSettingInput!): NotificationSetting

  """follow/unfollow"""
  followUser(input: FollowUserInput!): Boolean
  unfollowUser(input: UnfollowUserInput!): Boolean

  """
  misc
  importArticles(input: ImportArticlesInput!): [Article!]
  """
  clearReadHistory(input: ClearReadHistoryInput): Boolean
  clearSearchHistory: Boolean
  invite(input: InviteInput!): Boolean
}

interface Node {
  id: ID!
}

input NodeEditedInput {
  id: ID!
}

input NodeInput {
  id: ID!
}

interface Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
}

type NotificationSetting {
  enable: Boolean!
  mention: Boolean!
  follow: Boolean!
  comment: Boolean!
  appreciation: Boolean!
  articleSubscription: Boolean!
  commentSubscribed: Boolean!
  downstream: Boolean!
  commentPinned: Boolean!
  commentVoted: Boolean!

  """walletUpdate: Boolean!"""
  officialNotice: Boolean!
  reportFeedback: Boolean!
}

enum NotificationSettingType {
  enable
  mention
  follow
  comment
  appreciation
  articleSubscription
  commentSubscribed
  downstream
  commentPinned
  commentVoted
  officialNotice
  reportFeedback
}

type Official {
  reportCategory: [Category!]!
  feedbackCategory: [Category!]!
  releases(input: ReleasesInput!): [Release!]
  links: OfficialLinks!
  placements: Placements!
}

type OfficialAnnouncementNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  message: String!
  link: URL
}

type OfficialLinks {
  beginnerGuide: URL!
  userGuide: URL!
  about: URL!
  faq: URL!
  tos: URL!
}

input PinCommentInput {
  id: ID!
}

type Placements {
  webAsideTop: PlacementUnit!
  appSplash: PlacementUnit!
  appInStreamTop: PlacementUnit!
  appInStreamMiddle: PlacementUnit!
  appInStreamBottom: PlacementUnit!
  appInvitationTop: PlacementUnit!
}

type PlacementUnit {
  image: URL!
  link: URL!
  adLabel: Boolean!
}

enum PlatformType {
  ios
  android
}

input PublishArticleInput {
  id: ID!
  delay: Int
}

enum PublishState {
  draft
  pending
  error
  published
}

input PutAudioDraftInput {
  id: ID
  audioAssetId: ID
  title: String
  length: Int
}

input PutCommentInput {
  comment: CommentInput!
  id: ID
}

input PutDraftInput {
  id: ID
  upstreamId: ID
  title: String
  content: String!
  tags: [String]
  coverAssetId: ID
}

"""
The dummy queries and mutations are necessary because
graphql-js cannot have empty root types and we only extend
these types later on
Ref: apollographql/graphql-tools#293
"""
type Query {
  _: Boolean
  article(input: ArticleInput!): Article
  articles(input: ArticlesInput!): [Article!]
  node(input: NodeInput!): Node
  frequentSearch(key: String): [String!]
  search(input: SearchInput!): [SearchResult!]
  official: Official!
  viewer: User
  user(input: UserInput!): User
}

input ReadArticleInput {
  id: ID!
}

type ReadHistory {
  id: ID!
  article: Article!
  readAt: DateTime!
}

input RecallPublishInput {
  id: ID!
}

type Recommendation {
  followeeArticles(input: ListInput!): [Article!]
  newest(input: ListInput!): [Article!]
  hottest(input: ListInput!): [Article!]

  """In case you missed it"""
  icymi(input: ListInput!): [Article!]
  tags(input: ListInput!): [Tag!]
  topics(input: ListInput!): [Article!]
  authors(input: ListInput!): [User!]
}

type Release {
  title: String
  description: String
  cover: URL
  link: URL
  platform: PlatformType!
  channel: ChannelType!
  version: String!
  latest: Boolean!
  forceUpdate: Boolean!
  releasedAt: DateTime!
}

input ReleasesInput {
  platform: PlatformType!
  channel: ChannelType!
  offset: Int
  limit: Int
}

input ReportArticleInput {
  id: ID!
  category: String!
  description: String
  assetIds: [ID!]
  contact: String
}

input ReportCommentInput {
  id: ID!
  category: String!
  description: String
  assetIds: [ID!]
  contact: String
}

input SearchInput {
  key: String!
  type: SearchTypes!
  offset: Int
  limit: Int
}

type SearchResult {
  node: Node
  match: String
}

enum SearchTypes {
  Article
  User
  Tag
}

input SendVerificationCodeInput {
  email: Email!
  type: VerificationCodeType!
}

input SingleFileUploadInput {
  type: AssetType!
  file: Upload!
}

input SubscribeArticleInput {
  id: ID!
}

type SubscribedArticleNewCommentNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
  target: Article!
  comment: Comment!
}

type Subscription {
  _: Boolean
  nodeEdited(input: NodeEditedInput!): Node!
}

type Tag implements Node {
  id: ID!
  content: String!
  count: Int!
  articles(input: ListInput!): [Article!]
}

scalar Time

input ToggleArticleLiveInput {
  id: ID!
  enabled: Boolean!
}

input ToggleArticlePublicInput {
  id: ID!
  enabled: Boolean!
}

type Transaction {
  delta: Int!
  purpose: TransactionPurpose!
  reference: Node
  createdAt: DateTime!
}

enum TransactionPurpose {
  appreciate
  invitationAccepted
  joinByInvitation
  joinByTask
}

input UnfollowUserInput {
  id: ID!
}

input UnsubscribeArticleInput {
  id: ID!
}

input UnvoteCommentInput {
  id: ID!
}

input UpdateNotificationSettingInput {
  type: NotificationSettingType!
  enabled: Boolean!
}

input UpdateUserInfoInput {
  displayName: String
  userName: String
  avatar: ID
  description: String
  language: UserLanguage
}

scalar Upload

type UpstreamArticleArchivedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  upstream: Article!
  target: Article!
}

scalar URL

type User implements Node {
  id: ID!
  uuid: UUID!
  info: UserInfo!
  settings: UserSettings!
  recommendation: Recommendation!

  """Articles written by this user"""
  articles(input: ListInput!): [Article!]
  drafts(input: ListInput!): [Draft!]
  audioDrafts(input: ListInput!): [AudioDraft!]

  """Comments posted by this user"""
  commentedArticles(input: ListInput!): [Article!]

  """comments that quoted this user's article"""
  quotedArticles(input: ListInput!): [Article!]
  subscriptions(input: ListInput!): [Article!]
  activity: UserActivity!

  """Followers of this user"""
  followers(input: ListInput!): [User!]

  """Users that this user follows"""
  followees(input: ListInput!): [User!]

  """This user is following viewer"""
  isFollower: Boolean!

  """Viewer is following this user"""
  isFollowee: Boolean!
  status: UserStatus!
  notices(input: ListInput!): [Notice!]
}

type UserActivity {
  history(input: ListInput!): [ReadHistory!]
  recentSearches(input: ListInput!): [String!]
}

type UserInfo {
  createdAt: DateTime!

  """Unique user name"""
  userName: String!

  """Is user name editable"""
  userNameEditable: Boolean!

  """Display name on profile"""
  displayName: String!

  """User desciption"""
  description: String

  """URL for avatar"""
  avatar: URL
  email: Email
  mobile: String

  """Use 500 for now, adaptive in the future"""
  readSpeed: Int!
  badges: [Badge!]
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  mobile
}

input UserInput {
  userName: String!
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

input UserLoginInput {
  email: Email!
  password: String!
}

type UserNewFollowerNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User!]
}

input UserRegisterInput {
  email: Email!
  displayName: String!
  password: String!
  codeId: ID!
}

type UserSettings {
  """User language setting"""
  language: UserLanguage!

  """
  Thrid party accounts binded for the user
  oauthType: [OAuthType!]
  Notification settings
  """
  notification: NotificationSetting!
}

enum UserState {
  inactive
  onboarding
  active
  banned
  frozen
  archived
}

type UserStatus {
  state: UserState!

  """Total MAT left in wallet"""
  MAT: MAT!
  invitation: InvitationStatus!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of views on articles"""
  viewCount: Int!
  draftCount: Int!

  """Number of comments posted by user"""
  commentCount: Int!
  quotationCount: Int!
  subscriptionCount: Int!

  """Number of user that this user follows"""
  followeeCount: Int!

  """Number of user that follows this user"""
  followerCount: Int!

  """Number of unread notices"""
  unreadNoticeCount: Int!
}

scalar UUID

enum VerificationCodeType {
  register
  email_reset
  password_reset
  email_verify
}

enum Vote {
  up
  down
}

input VoteCommentInput {
  vote: Vote!
  id: ID!
}
